# 11.5 - INSERT

> 일반적으로 온라인 트랜잭션 서비스에서 INSERT 문장은 대부분 1건 또는 소량의 레코드를 INSERT하는 형태이므로 그다지 성능에 대해서 고려할 부분이 많지 않다. 오히려 많은 INSERT 동시에 실행되는 경우 INSERT 문장 자체보다는 테이블의 구조가 성능에 더 큰 영향을 미친다. 하지만 많은 경우 INSERT의 성능과 SELECT의 성능을 동시에 빠르게 만들 수 있는 테이블 구조는 없다. 그래서 INSERT와 SELECT 성능을 어느 정도 타협하면서 테이블 구조를 설계해야 한다. 여기서는 INSERT 문장의 주의사항 몇 가지와 테이블의 용도에 따라 테이블 구조를 선택하는 방법을 간단히 살펴보겠다.

## 1. INSERT 고급 옵션

### INSERT IGNORE

INSERT 문장의 IGNORE 옵션은 저장하는 레코드의 프라이머리 키나 유니크 인덱스 컬럼의 값이 미리 테이블에 존재하는 레코드와 중복되는 경우, 그리고 저장하는 레코드의 컬럼이 테이블의 컬럼과 호환되지 않는 경우 모두 무시하고 다음 레코드를 처리할 수 있게 해준다.

IGNORE 옵션은 아래와 같이 하나의 INSERT 문장으로 여러 레코드를 처리하는 경우 유용하다.

```sql
INSERT IGNORE INTO salaries (emp_no, salary, from_date, to_date) VALUES
    (10001, 60117, '1986-06-26', '1987-06-26'),
    (10001, 62102, '1987-06-26', '1988-06-25'),
    (10001, 66074, '1988-06-25', '1989-06-25'),
    (10001, 66596, '1989-06-25', '1990-06-25'),
    (10001, 66961, '1990-06-25', '1991-06-25');

INSERT IGNORE INTO salaries
    SELECT emp_no, (salary+100), '2020-01-01', '2022-01-01'
    FROM salaries
    WHERE to_date >= '2020-01-01';
```

`salaries` 테이블의 프라이머리 키가 `(emp_no, from_date)` 이면 INSERT되는 레코드 값이 이미 테이블에 존재하는 레코드의 `(emp_no, from_date)` 조합과 중복되는 경우 해당 레코드는 에러가 발생한다. 하지만 IGNORE 옵션이 있는 경우, 에러를 경고 수준의 메시지로 바꾸고 나머지 레코드의 INSERT를 계속 진행한다. INSERT하고자 하는 데이터가 정교하지 않아도 되는 경우 INSERT를 실행하기 전에 레코드 건건이 중복 체크를 실행하지 않고 INSERT IGNORE 명령으로 처리하는 방식으로 자주 사용된다.

데이터 타입이 일치하지 않는 경우 INSERT IGNORE 옵션은 해당 컬럼의 기본 값으로 INSERT를 하도록 만들기도 한다.

### INSERT ... ON DUPLICATE KEY UPDATE

INSERT ... ON DUPLICATE KEY UPDATE 문장은 프라이머리 키나 유니크 인덱스의 중복이 발생하면 UPDATE 문장의 역할을 수행하게 해준다. MySQL의 REPLACE 문장도 비슷한 역할을 하지만 내부적으로는 DELETE와 INSERT의 조합으로 작동한다. 하지만 INSERT ... ON DUPLICATE KEY UPDATE 문장은 중복된 레코드가 있다면 기존 레코드를 삭제하지 않고 기존 레코드의 컬럼을 UPDATE하는 방식으로 동작한다.

INSERT ... ON DUPLICATE KEY UPDATE는 아래 쿼리와 같이 일별로 집계되는 값을 관리할 때 편하게 사용할 수 있다.

```sql
CREATE TABLE daily_statistics (
    target_date DATE NOT NULL,
    stat_name VARCHAR(10) NOt NULL.
    stat_value BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY(target_date, stat_name)
);

INSERT INTO daily_statistics (target_date, stat_name, stat_value)
    VALUES (DATE(NOW()), 'VISIT', 1)
    ON DUPLICATE KEY UPDATE stat_value=stat_value+1;
```

`daily_statistics` 테이블의 프라이머리 키는 `(target_date, stat_name)` 조합으로 생성돼 있기 때문에 일별로 `stat_name`은 하나씩만 존재할 수 있다. 그래서 특정 날짜의 `stat_name`이 최초로 저장되는 경우에는 INSERT 문장만 실행되고, ON DUPLICATE KEY UPDATE 절 이하의 내용은 무시된다. 이미 레코드가 존재한다면 INSERT 대신 ON DUPLICATE KEY UPDATE 절 이하의 내용이 실행된다. 쿼리에서 이미 해당 날짜의 집계 레코드가 존재한다면 기존 레코드의 `stat_value` 컬럼의 값을 1을 더한 값을 UPDATE한다.

아래 쿼리는 배치 형태로 GROUP BY된 결과를 `daily_statistics` 테이블에 한 번에 INSERT하는 예제다.

```sql
INSERT INTO daily_statistics
    SELECT DATE(visited_at), 'VISIT', COUNT(*)
    FROM access_log
    GROUP BY DATE(visited_at)
    ON DUPLICATE KEY UPDATE stat_value=stat_value + COUNT(*);
```

위 쿼리에서 `stat_value` 컬럼에는 GROUP BY 결과 건수를 저장하고 있다. 이 쿼리에서 이미 해당 일자와 `stat_name`이 동일한 레코드가 있다면 ON DUPLICATE KEY UPDATE 절이 실행될 것이다. 그런데 ON DUPLICATE KEY UPDATE절에서 GROUP BY의 결과인 `COUNT(*)`을 참조할 수 없어서 `Invalid use of group function` 에러가 발생한다. 이러한 경우 `VALUES()` 함수를 사용하면 된다.

```sql
INSERT INTO daily_statistics
    SELECT DATE(visited_at), 'VISIT', COUNT(*)
    FROM access_log
    GROUP BY DATE(visited_at)
    ON DUPLICATE KEY UPDATE stat_value=stat_value + VALUES(stat_value);
```

위와 같이 `VALUES()` 함수를 사용하면 MySQL 서버는 인자로 주어진 `stat_value` 컬럼에 INSERT하려고 했던 값을 반환한다. INSERT 절에서 실제 저장하려고 했던 값이 무엇인지 몰라도, `VALUES(stat_value)` 함수를 사용하면 INSERT하고자 했던 값을 다시 가져올 수 있다. MySQL 8.0.20 이후 버전부터는 `VALUES()` 함수가 지원되지 않을 예정이므로(Deprecated) 다른 문법으로 대체해서 사용할 것을 권장한다.

---

## 2. LOAD DATA 명령 주의 사항

일반적으로 RDBMS에서 데이터를 빠르게 적재할 수 있는 방법으로 LOAD DATA 명령이 자주 소개된다. MySQL 서버의 LOAD DATA 명령도 내부적으로 MySQL 엔진과 스토리지 엔진의 호출 횟수를 최소화하고 스토리지 엔진이 직접 데이터를 적재하기 때문에 일반적인 INSERT 명령과 비교했을 때 매우 빠르다고 할 수 있다. 하지만 MySQL 서버의 LOAD DATA 명령은 다음과 같은 단점이 있다.

- 단일 스레드로 실행
- 단일 트랜잭션으로 실행

LOAD DATA 명령은 단일 스레드와 단일 트랜잭션으로 실행되기 때문에 적재해야 할 데이터 파일이 매우 크다면 시간이 매우 길어질 수 있다. 또한 LOAD DATA 명령이 시작한 시점부터 언두 로그가 삭제되지 못하고 유지돼야 한다. 가능하다면 LOAD DATA 문장으로 적재할 데이터 파일을 하나보다는 여러 개의 파일로 준비해서 LOAD DATA 문장을 동시에 여러 트랜잭션으로 나뉘어 실행되게 하는게 좋다.

---

## 3. 성능을 위한 테이블 구조

### 1. 대량 INSERT 성능

하나의 INSERT 문장으로 수백 건, 수천 건의 레코드를 INSERT한다면 INSERT될 레코드들을 프라이머리 키 값을 기준으로 미리 정렬해서 INSERT 문장을 구성하는 것이 성능에 도움이 될 수 있다. INSERT 성능은 프라이머리 키 정렬 여부가 많이 결정한다.

### 2. 프라이머리 키 선정

SELECT는 거의 실행되지 않고 INSERT가 매우 많이 실행되는 테이블이라면 테이블의 프라이머리 키를 단조 증가 또는 단조 감소하는 패턴의 값을 선택하는 것이 좋다. 주로 로그를 저장하는 테이블이 이런 류에 속한다. 하지만 SELECT 쿼리의 비율이 훨씬 높은 대부분의 온라인 트랜잭션 처리를 위한 테이블들은 INSERT보다는 SELECT 쿼리를 빠르게 만드는 방향으로 프라이머리 키를 선정해야 한다.

---

## Ref

- Real MySQL 8.0 2 - p.148 ~ p.159

---
