# 13.3 파티션 - MySQL 파티션의 종류

## MySQL 파티션의 종류

다른 DBMS와 마찬가지로 MySQL에서도 아래와 같은 4가지 기본 파티션 기법을 제공하고 있다.

- 레인지 파티션
- 리스트 파티션
- 해시 파티션
- 키 파티션

추가로 해시 파티션과 키 파티션에 대해서는 리니어(Linear) 파티션과 같은 추가적인 기법도 제공한다.

---

## 1. [레인지 파티션](https://dev.mysql.com/doc/refman/8.4/en/partitioning-range.html)

### 1. 레인지 파티션의 용도

레인지 파티션은 파티션 키의 연속된 범위로 파티션을 정의하는 방법으로, 가장 일반적으로 사용되는 파티션 방법 중 하나다. 다른 파티션 방법과는 달리 `MAXVALUE`라는 키워드를 이용해 명시되지 않은 범위의 키 값이 담긴 레코드를 저장하는 파티션을 정의할 수 있다.

다음과 같은 성격을 지닌 테이블에서는 레인지 파티션을 사용하는 것이 좋다.

- 날짜를 기반으로 데이터가 누적되고 연도나 월, 또는 일 단위로 분석하고 삭제해야 할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 자주 실행될 때

레인지 파티션은 필요한 파티션만 접근한다는 장점의 효과가 매우 큰 파티션으로 로그 테이블 등에 적합하다.

### 2. 레인지 파티션의 추가

새로운 파티션을 추가할 경우 해당 범위를 포함하는 파티션의 데이터를 새로운 파티션에 복사하는 작업을 필요로 한다. `MAXVALUE` 절을 사용하지 않고 미래에 사용될 파티션을 미리 몇 개 만드는 방식도 활용하며 이를 배치 스크립트로 자동화하기도 한다. 데이터가 적은 경우 복사 작업의 성능 문제는 없지만 데이터가 많은 경우 오랜 시간이 걸릴 수 있다.

### 3. 레인지 파티션의 삭제

특정 파티션을 삭제하는 작업은 아주 빠르게 처리 된다.

### 4. 레인지 파티션의 분리

하나의 파티션을 두 개 이상의 파티션으로 분리할 수 있으며 기존 파티션에 레코드가 많다면 재배치에 시간이 많이 소요될 수 있다. 파티션이 재구성되는 동안 S-Lock이 필요하므로 작업 진행에 주의해야 한다.

### 5. 레인지 파티션의 병합

여러 파티션을 하나의 파티션으로 병합할 수 있으며 이 역시 파티션이 재구성되는 동안 S-Lock이 필요하다.

---

## 2. [리스트 파티션](https://dev.mysql.com/doc/refman/8.4/en/partitioning-list.html)

### 1. 리스트 파티션의 용도

리스트 파티션은 레인지 파티션과 많은 부분에서 흡사하게 동작한다. 둘의 가장 큰 차이는 레인지 파티션은 파티션 키 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 키 값 하나하나를 리스트로 나열해야 한다는 점이다.

다음과 같은 성격을 지닌 테이블에서는 리스트 파티션을 사용하는 것이 좋다.

- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때

### 2. 리스트 파티션의 추가, 삭제, 분리, 병합

레인지 파티션과 특성이 동일하다.

---

## 3. [해시 파티션](https://dev.mysql.com/doc/refman/8.4/en/partitioning-hash.html)

### 1. 해시 파티션의 용도

해시 파티션은 MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법이다. 해시 파티션의 파티션 키는 항상 정수 타입의 컬럼이거나 정수를 반환하는 표현식만 사용될 수 있으며 이를 파티션의 개수로 나눈 나머지로 저장될 파티션을 결정한다.

다음과 같은 성격을 지닌 테이블에서는 해시 파티션을 사용하는 것이 좋다.

- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때

### 2. 해시 파티션의 추가

새로운 파티션이 추가된다면 기존의 각 파티션에 저장된 모든 레코드가 재배치되야 한다.

### 3. 해시 파티션의 삭제

파티션 단위로 레코드를 삭제하는 방법이 없다. MySQL 서버가 지정한 파티션 키 값을 가공해서 데이터를 분산한 것이므로 파티션 단위로 데이터를 삭제하는 작업은 의미도 없으며 해서도 안 될 작업이다.

### 4. 해시 파티션의 분리, 병합

파티션을 분리하거나 병합하는 기능은 없으며 테이블 전체적으로 파티션의 개수를 조절하는 것만 가능하다. 파티션 개수의 변경은 레인지 파티션이나 리스트 파티션과 달리 테이블의 모든 레코드의 재배치 작업으로 이어진다.

---

## 4. [키 파티션](https://dev.mysql.com/doc/refman/8.4/en/partitioning-key.html)

키 파티션은 해시 파티션과 사용법과 특성이 거의 같다. 해시 파티션은 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시하지만, 키 파티션은 그마저도 MySQL 서버가 수행한다. 따라서 정수 타입이나 정수를 반환하는 표현식뿐만 아니라 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있다. 키 파티션은 내부적으로 `MD5()` 함수를 이용해 파티션한다.

---

## 5. [리니어 해시 파티션 / 리니어 키 파티션](https://dev.mysql.com/doc/refman/8.4/en/partitioning-linear-hash.html)

해시 파티션이나 키 파티션은 파티션의 개수가 바뀌면 테이블 전체 레코드의 재분배 작업이 발생하는데 이러한 단점을 최소화하기 위해 고안된 알고리즘이 리니어 해시 파티션과 리니어 키 파티션이다. 리니어 파티션은 `Power-of-two(2의 승수)` 알고리즘을 이용하여 파티션의 추가나 통합 시 다른 파티션에 미치는 영향을 최소화해준다.

### 1. 리니어 파티션 매커니즘

$X$ 를 $Y$ 로 나눈 나머지는 $X\ \%\ Y$ 로 구할 수 있는데 mod 연산은 비용이 비싸다. 만약 $Y$ 가 2의 거듭제곱 꼴이라면 $X\ \&\ (Y - 1)$ 로 비트 AND 연산으로 나머지를 구할 수 있다.

지정한 파티션의 수를 $num$ 이라고 했을 때, $num$ 이상인 2의 거듭제곱 $V$ 를 구한다. 예를 들어 $num = 13$ 이면 $V = 2^{\lceil \log_2{num} \rceil} = 16$ 이 된다.

위의 $V$ 가 2의 거듭제곱 꼴이므로 비트 AND 연산으로 레코드가 위치할 파티션의 번호 $N$ 을 구할 수 있다. 이때 실제 파티션의 수 $num$ 은 $V$ 보다 작거나 같은데 $N\ \&\ (V - 1)$ 로 계산한 파티션 번호 $N$ 가 $num$ 보다 작으면 해당 위치에 넣고, $num$ 보다 크거나 같으면 $N\ \&\ (V / 2 - 1)$ 을 한 위치에 넣는다.

### 2. 리니어 파티션의 특징

리니어 파티션은 파티션의 개수가 변경되는 상황에서 레코드의 이동이 기존 해시 파티션이나 키 파티션보다 적다는 장점이 있다. 하지만 각 파티션이 가지는 레코드가 비교적 덜 균등해질 수 있어서 파티션의 개수 변경이 잦다면 리니어 파티션을 고려하고 그렇지 않다면 해시 파티션이나 키 파티션을 사용하는 것이 좋다.

---

## Ref

- Real MySQL 8.0 2 - p.276 ~ p.292

---
